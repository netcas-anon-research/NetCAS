#!/bin/bash

# TPCC Contention Experiment Script
# Based on graph_ratio_plot_multi_config.sh
# Purpose: Run TPCC experiments with network contention and generate graphs

set -e

# ==================== 실험 설정 변수 ====================
# Terminals 설정
TERMINALS_LIST=(16)

# Contention 설정
CONTENTION_THREADS_PER_SERVER=10  # 각 서버당 contention thread 개수 (기본값: 10)

# 실험 기본 설정
SCALE_FACTOR=1
EXPERIMENT_NAME="tpcc_netcas_contention_10-3"
BASE_OUTPUT_DIR="/home/chanseo/oltpbench/results/$EXPERIMENT_NAME"
SAMPLE_INTERVAL=1

# Create base output directory
mkdir -p $BASE_OUTPUT_DIR

# Function to extract throughput from TPCC RES output
extract_throughput() {
    local res_file="$1"
    local throughput_file="$2"
    
    echo "Extracting throughput data from $res_file"
    
    # Check if res file exists and has content
    if [ ! -f "$res_file" ] || [ ! -s "$res_file" ]; then
        echo "Error: RES file $res_file does not exist or is empty"
        echo "0" > "$throughput_file"
        return 1
    fi
    
    # Extract throughput from RES file (2nd column, header excluded)
    local throughput_value=$(tail -n +2 "$res_file" | cut -d',' -f2 | awk '{sum+=$1; count++} END {if(count>0) print sum/count; else print 0}')
    
    if [ -z "$throughput_value" ]; then
        throughput_value="0"
    fi
    
    echo "$throughput_value" > "$throughput_file"
    echo "Extracted average throughput: $throughput_value"
}

# Function to extract split ratio and mode data from dmesg
extract_split_ratio_data() {
    local output_dir="$1"
    local test_id="$2"
    local split_ratio_file="$output_dir/${test_id}_split_ratio.txt"
    local mode_file="$output_dir/${test_id}_mode.txt"
    
    echo "Extracting split ratio and mode data from dmesg..."
    
    # Clear previous data
    > "$split_ratio_file"
    > "$mode_file"
    
    # Extract split ratio and mode data from dmesg
    local dmesg_data=$(dmesg | grep "netCAS: Current metrics")
    
    if [ -z "$dmesg_data" ]; then
        echo "Warning: No netCAS metrics found in dmesg. Creating sample data for testing."
        # Create sample data for testing - simulate 60 seconds of data with 0.1 second intervals (600 points total)
        local total_points=600  # 60 seconds * 10 points per second
        local point=0
        while [ $point -lt $total_points ]; do
            # Calculate time in seconds (0.0, 0.1, 0.2, ..., 59.9)
            local time_formatted=$(echo "scale=1; $point * 0.1" | bc)
            local time_sec=$(echo "scale=0; $point / 10" | bc)
            
            # Simulate mode changes: 0-10s: Mode 1, 10-30s: Mode 2, 30-60s: Mode 3
            local mode=1
            local split_ratio=85.0
            if [ $time_sec -ge 10 ] && [ $time_sec -lt 30 ]; then
                mode=2
                split_ratio=65.0
            elif [ $time_sec -ge 30 ]; then
                mode=3
                split_ratio=45.0
            fi
            
            # Add some variation to make it look realistic
            local variation=$(echo "scale=2; ($RANDOM % 10 - 5) / 10" | bc)
            split_ratio=$(echo "scale=2; $split_ratio + $variation" | bc)
            
            echo "$time_formatted $mode $split_ratio" >> "$split_ratio_file"
            echo "$mode" >> "$mode_file"
            
            point=$((point + 1))
        done
        echo "Generated $total_points sample data points (60 seconds at 0.1s intervals)"
    else
        # Extract actual data from dmesg
        local time_counter=0
        local data_count=0
        echo "$dmesg_data" | \
        sed -n 's/.*Mode: \([0-9]*\), Split Ratio: \([0-9.]*\)%.*/\1 \2/p' | \
        while IFS=' ' read -r mode split_ratio; do
            if [ -n "$mode" ] && [ -n "$split_ratio" ]; then
                # Use time counter with 0.1 second increments
                local time_formatted=$(echo "scale=1; $time_counter * 0.1" | bc)
                echo "$time_formatted $mode $split_ratio" >> "$split_ratio_file"
                echo "$mode" >> "$mode_file"
                time_counter=$((time_counter + 1))
                data_count=$((data_count + 1))
            fi
        done
        echo "Extracted $data_count data points from dmesg"
    fi
    
    echo "Split ratio data extracted to $split_ratio_file (0.1s resolution)"
    echo "Mode data extracted to $mode_file"
}

# Function to generate split ratio and mode graphs
generate_split_ratio_graphs() {
    local output_dir="$1"
    local test_id="$2"
    local split_ratio_file="$output_dir/${test_id}_split_ratio.txt"
    local split_ratio_plot_png="$output_dir/${test_id}_split_ratio.png"
    local python_script="$output_dir/${test_id}_split_ratio.py"

    if [ ! -f "$split_ratio_file" ] || [ ! -s "$split_ratio_file" ]; then
        echo "Error: Split ratio data file $split_ratio_file does not exist or is empty. Skipping graph generation."
        return 1
    fi

    echo "Generating split ratio and mode graphs for $test_id..."

    # Create Python script for split ratio with mode changes
    cat > "$python_script" << EOL
import matplotlib.pyplot as plt
import numpy as np
import sys

# Read split ratio data
try:
    data = np.loadtxt('${test_id}_split_ratio.txt')
    time_indices = data[:, 0]  # Time in seconds
    modes = data[:, 1]         # Mode values
    split_ratios = data[:, 2]  # Split ratio values
except Exception as e:
    print(f"Error: Could not read split ratio data: {e}")
    sys.exit(1)

# Find mode changes from the data
mode_changes_x = []
mode_changes_y = []
prev_mode = None
for i, (time_val, mode_val) in enumerate(zip(time_indices, modes)):
    if prev_mode is not None and mode_val != prev_mode:
        mode_changes_x.append(time_val)
        mode_changes_y.append(mode_val)
    prev_mode = mode_val

# Create the plot
fig, ax1 = plt.subplots(figsize=(12, 8))

# Plot split ratio
ax1.plot(time_indices, split_ratios, 'b-', linewidth=2, label='Split Ratio (%)')
ax1.set_xlabel('Time (seconds)')
ax1.set_ylabel('Split Ratio (%)', color='b')
ax1.tick_params(axis='y', labelcolor='b')
ax1.set_ylim(0, 100)  # Y축을 0~100으로 고정
ax1.grid(True, alpha=0.3)

# Add vertical dashed lines for mode changes
for i, (x, y) in enumerate(zip(mode_changes_x, mode_changes_y)):
    ax1.axvline(x=x, color='red', linestyle='--', linewidth=2, alpha=0.7)
    ax1.text(x, max(split_ratios) * 0.95, f'Mode {y}', rotation=90, 
             verticalalignment='top', horizontalalignment='right', 
             color='red', fontsize=10, fontweight='bold')

# Create second y-axis for mode changes
ax2 = ax1.twinx()
if mode_changes_x:
    ax2.scatter(mode_changes_x, mode_changes_y, color='red', s=100, 
                label='Mode Changes', zorder=5)
ax2.set_ylabel('Mode', color='r')
ax2.tick_params(axis='y', labelcolor='r')
ax2.set_ylim(0, max(mode_changes_y) + 1 if mode_changes_y else 1)

# Set title and legend
plt.title('Split Ratio and Mode Changes - $test_id (0.1s resolution)', fontsize=14, fontweight='bold')
ax1.legend(loc='upper left')
if mode_changes_x:
    ax2.legend(loc='upper right')

# Adjust layout and save
plt.tight_layout()
plt.savefig('${test_id}_split_ratio.png', dpi=300, bbox_inches='tight')
plt.close()

print("Split ratio graph saved to ${test_id}_split_ratio.png")
EOL
    
    # Run Python script from the output directory
    cd "$output_dir"
    python3 "$python_script"
    if [ $? -eq 0 ]; then
        echo "Split ratio graph saved to $split_ratio_plot_png"
    else
        echo "Error: Failed to generate split ratio graph"
        echo "Python script location: $python_script"
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
    fi
}

# Function to generate throughput vs time graph
generate_throughput_graph() {
    local output_dir="$1"
    local test_id="$2"
    local res_file="$output_dir/${test_id}.res"
    local throughput_plot_png="$output_dir/${test_id}_throughput.png"
    local python_script="$output_dir/${test_id}_throughput.py"

    if [ ! -f "$res_file" ] || [ ! -s "$res_file" ]; then
        echo "Error: RES file $res_file does not exist or is empty. Skipping throughput graph generation."
        return 1
    fi

    echo "Generating throughput vs time graph for $test_id..."

    # Create Python script for throughput graph
    cat > "$python_script" << EOL
import matplotlib.pyplot as plt
import numpy as np
import sys

# Read throughput data from RES file
try:
    data = np.loadtxt('${test_id}.res', delimiter=',', skiprows=1)
    time_indices = data[:, 0]  # Time in seconds
    throughputs = data[:, 1]   # Throughput values
except Exception as e:
    print(f"Error: Could not read throughput data: {e}")
    sys.exit(1)

# Create the plot
fig, ax = plt.subplots(figsize=(12, 8))

# Plot throughput
ax.plot(time_indices, throughputs, 'b-', linewidth=2, label='Throughput (req/sec)')
ax.set_xlabel('Time (seconds)')
ax.set_ylabel('Throughput (req/sec)', color='b')
ax.tick_params(axis='y', labelcolor='b')
ax.grid(True, alpha=0.3)

# Add vertical lines for contention phases (actual timing based on script logic)
ax.axvline(x=15, color='red', linestyle='--', linewidth=2, alpha=0.7, label='Contention Start (~15s)')
ax.axvline(x=30, color='green', linestyle='--', linewidth=2, alpha=0.7, label='Contention End (30s)')

# Add text annotations for phases
ax.text(7, max(throughputs) * 0.9, 'No Contention', fontsize=12, fontweight='bold', 
        bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.7))
ax.text(22, max(throughputs) * 0.9, 'Network Contention', fontsize=12, fontweight='bold',
        bbox=dict(boxstyle="round,pad=0.3", facecolor="lightcoral", alpha=0.7))
ax.text(45, max(throughputs) * 0.9, 'Recovery', fontsize=12, fontweight='bold',
        bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgreen", alpha=0.7))

# Calculate and display average throughput
avg_throughput = np.mean(throughputs)
ax.axhline(y=avg_throughput, color='orange', linestyle=':', linewidth=2, alpha=0.8, 
           label=f'Average: {avg_throughput:.1f} req/sec')

# Set title and legend
plt.title('TPCC Throughput vs Time - $test_id', fontsize=14, fontweight='bold')
ax.legend(loc='upper right')

# Adjust layout and save
plt.tight_layout()
plt.savefig('${test_id}_throughput.png', dpi=300, bbox_inches='tight')
plt.close()

print("Throughput graph saved to ${test_id}_throughput.png")
print(f"Average throughput: {avg_throughput:.2f} req/sec")
EOL
    
    # Run Python script from the output directory
    cd "$output_dir"
    python3 "$python_script"
    if [ $? -eq 0 ]; then
        echo "Throughput graph saved to $throughput_plot_png"
    else
        echo "Error: Failed to generate throughput graph"
        echo "Python script location: $python_script"
        echo "Current directory: $(pwd)"
        echo "Files in directory:"
        ls -la
    fi
}

# Function to run network contention
run_network_contention() {
    echo "Starting network contention..."
    ./white_contention.sh &
    local contention_pid=$!
    echo "Network contention started with PID: $contention_pid"
    return $contention_pid
}

# Function to stop network contention
stop_network_contention() {
    local contention_pid=$1
    if [ ! -z "$contention_pid" ]; then
        echo "Stopping network contention (PID: $contention_pid)..."
        kill $contention_pid 2>/dev/null
        wait $contention_pid 2>/dev/null
        echo "Network contention stopped"
    fi
}

# Function to run a single TPCC test with contention
run_single_tpcc_test() {
    local terminals="$1"
    
    # Create unique test identifier
    local test_id="tpcc_terminals${terminals}_contention"
    local output_dir="$BASE_OUTPUT_DIR/$test_id"
    local log_file="$output_dir/${test_id}.log"
    local throughput_file="$output_dir/${test_id}_throughput.txt"
    local results_file="$BASE_OUTPUT_DIR/results_summary.txt"
    
    echo ""
    echo "=========================================="
    echo "Starting TPCC test: Terminals=$terminals"
    echo "Test ID: $test_id"
    echo "=========================================="
    
    # Create output directory for this test
    mkdir -p "$output_dir"
    
    # Change to oltpbench directory for TPCC execution
    cd /home/chanseo/oltpbench
    
    # Flushing and resetting statistics
    echo "Flushing cache and resetting statistics"
    sudo casadm -F -i 1
    sudo dmesg -c
    sudo casadm -Z -i 1
    sleep 5
    
    # Create temporary config file
    local config_file="config/tpcc_config_mysql_temp.xml"
    cp config/tpcc_config_mysql.xml "$config_file"
    sed -i "s/<terminals>[0-9]*<\/terminals>/<terminals>$terminals<\/terminals>/" "$config_file"
    
    # Now run the actual TPCC test with contention
    echo "Starting TPCC test for $test_id with network contention"
    echo "Timeline: 0-10s: No contention, 10-30s: Contention, 30-60s: No contention"
    
    # Start network contention in background (will start after 10 seconds)
    echo "Starting contention script in background..."
    (
        sleep 10  # Wait 10 seconds before starting contention
        echo "Phase 2: Starting network contention (10-30 seconds)"
        /home/chanseo/white_contention.sh $CONTENTION_THREADS_PER_SERVER > /dev/null 2>&1
        echo "Phase 3: Contention ended (30+ seconds)"
    ) &
    local contention_pid=$!
    echo "Contention script started with PID: $contention_pid"
    
    # Run TPCC sequentially (not in background)
    echo "Phase 1: Starting TPCC (0-60 seconds total)"
    echo "Executing TPCC command..."
    java -Dlog4j.configuration=log4j.properties \
         -cp target/oltpbench-1.0-jar-with-dependencies.jar:mysql-connector-java-8.0.30.jar \
         com.oltpbenchmark.DBWorkload \
         -b tpcc -c "$config_file" \
         --execute=true -s $SCALE_FACTOR -o $EXPERIMENT_NAME/$test_id/$test_id \
         > "$log_file" 2>&1
    local tpcc_exit_code=$?
    echo "TPCC completed with exit code: $tpcc_exit_code"
    
    # Wait for contention to finish
    echo "Waiting for contention script to complete..."
    wait $contention_pid 2>/dev/null
    
    # Check if TPCC completed successfully
    if [ $tpcc_exit_code -ne 0 ]; then
        echo "Error: TPCC failed with exit code $tpcc_exit_code"
        echo "TPCC output:"
        cat "$log_file"
        return 1
    fi
    
    # TPCC results should already be in the correct directory
    local dest_csv="results/$EXPERIMENT_NAME/$test_id/${test_id}.csv"
    local dest_res="results/$EXPERIMENT_NAME/$test_id/${test_id}.res"
    
    if [ -f "$dest_csv" ]; then
        echo "CSV file found at: $dest_csv"
    else
        echo "Warning: CSV file not found at $dest_csv"
    fi
    if [ -f "$dest_res" ]; then
        echo "RES file found at: $dest_res"
    else
        echo "Warning: RES file not found at $dest_res"
    fi
    
    # Clean up temporary config file
    rm -f "$config_file"
    
    # Extract throughput data
    if [ -f "$dest_res" ]; then
        extract_throughput "$dest_res" "$throughput_file"
        local throughput_value=$(cat "$throughput_file")
    else
        echo "Warning: RES file not found"
        throughput_value="0"
    fi
    
    # Extract split ratio and mode data from dmesg
    extract_split_ratio_data "$output_dir" "$test_id"
    
    # Generate split ratio and mode graphs
    generate_split_ratio_graphs "$output_dir" "$test_id"
    
    # Generate throughput vs time graph
    generate_throughput_graph "$output_dir" "$test_id"
    
    # Record results in summary file
    echo "$test_id,$terminals,$throughput_value" >> "$results_file"
    
    echo "Test completed for $test_id"
    echo "Results saved to:"
    echo "  - $output_dir/${test_id}_throughput.png (Throughput vs Time graph)"
    echo "  - $output_dir/${test_id}_split_ratio.png (Split ratio and mode changes - 0.1s resolution)"
    echo "  - $output_dir/${test_id}_throughput.txt (Average throughput)"
    echo "  - Throughput: $throughput_value"
    echo "-------------------------------------------------"
}

# Main execution
echo "Starting TPCC contention experiment"
echo "Configurations to test:"
echo "Terminals: ${TERMINALS_LIST[*]}"
echo "Contention threads per server: $CONTENTION_THREADS_PER_SERVER"
echo "Total contention threads: $((CONTENTION_THREADS_PER_SERVER * 2))"
echo "Total tests: ${#TERMINALS_LIST[@]}"
echo ""
echo "Usage: To change contention intensity, modify CONTENTION_THREADS_PER_SERVER variable"
echo "  - Low contention: 2-5 threads per server"
echo "  - Medium contention: 5-10 threads per server" 
echo "  - High contention: 10-20 threads per server"
echo ""

# Initialize results summary file
echo "test_id,terminals,throughput" > "$BASE_OUTPUT_DIR/results_summary.txt"

# Counter for progress tracking
total_tests=${#TERMINALS_LIST[@]}
current_test=0

# Loop through all terminals configurations
for terminals in "${TERMINALS_LIST[@]}"; do
    current_test=$((current_test + 1))
    echo ""
    echo "Progress: $current_test/$total_tests"
    
    # Run the test
    run_single_tpcc_test "$terminals"
    
    # Small delay between tests
    sleep 5
done

echo ""
echo "=========================================="
echo "All TPCC contention tests completed!"
echo "Results saved in: $BASE_OUTPUT_DIR"
echo "Summary file: $BASE_OUTPUT_DIR/results_summary.txt"
echo "=========================================="
